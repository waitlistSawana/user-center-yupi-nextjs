# 鱼皮用户中心项目改 Nextjs 开发记录

这个项目是跟着鱼皮编程导航的项目做的，目的是为了熟悉鱼皮写项目的风格，也是教程推荐的第一个项目，方便后面跟着一起做。

工具方面主要用 Trae （VsCode） 来写代码，AI 辅助。

## 01 启动项目

这个项目是用 Nextjs 15 App Router 开发的，原本的项目架构是 React + Java。原因是之前已经做过很多基于 Nextjs 的项目了。Nextjs 可以同时写前后端，前端基于 React，后端用 TS/JS 写，nodejs 风格。

另外的原因是 Java 没有启动起来。常用的 IDEA 是 VsCode，和鱼皮教程中的环境不太相同，需要再去额外找新的资料，所以干脆用自己最熟悉的 Nextjs 开发了。

启动项目，就是用到了 [Create T3 Stack](https://create.t3.gg/) 的项目模板，用到了 Drizzle ORM + Mysql + tRPC 等技术栈。这个模板非常适合开发一个类型安全的 Nextjs 项目，配置好了 eslint、prettier 等工具，也有 `start-database` 代码可以直接再 Docker Destop 中启动一个数据库。总之很好用，推荐。

## 02 创建和连接数据库

数据库和项目模板都创建好了，就可以配置 Drizzle ORM 了。在 `src/server/db/schema.ts` 文件中写好用户表的创建，然后运行 `pnpm db:generate` 和 `pnpm db:push`，就链接完成数据库了。使用 `pnpm db:studio` 可以打开数据库的可视化界面，检查数据库连接是否正常。

其次是学习 Java 的分层架构，这个项目中用到了分层架构。Java 分为三层：controller、service、dao/repositories。controller 层负责处理请求，service 层负责业务逻辑，dao/repositories 层负责数据访问。

而对于 Nextjs 的迁移，我创建了 `src/server/services/` 文件夹来管理 service 层的代码；`src/server/repositories/` 文件夹来管理 dao/repositories 层的代码；对于 controller 层的代码，它是直接处理请求的，Nextjs 的 API 路由就是这个作用，还是保留来原有的端点。

目前还没有使用 tRPC 框架，因为 API 端点更加直观，也更符合 Java 代码的风格，tRPC 的调用更适合直接用在 React 组件中。

## 03 登录注册功能

创建了两个端点，登录和注册。主要是在 repositories 中写好了数据库的增改函数，然后在 service 中调用，构建业务函数。这里，因为还不知道有哪些好用的生成工具，鱼皮可以直接安装插件来生成 mapping 的代码。以后也找找看，说不定 drizzle 也有类似的插件。

另外也学会了比较正式的注释方法 `/** */` 方式。主要是 JSDOC 的语法，包括在文件头部说明文件名，作者，日期，@see 等标签，在函数上方，写上标题、@description 说明，@param 说明参数，@return 说明返回值，@throws 说明抛出的异常，@examples 调用示例等等。之后就能直接在函数上看到注释了，原来注释是写在函数上方的，学到了。

对于具体的函数，也是跟着鱼皮的逻辑，改造为了 TS 代码，但有些部分可能用了别的替代方案。

## 04 测试代码

TS/JS 的测试主要有两个比较知名的 Jest 和 Vitest，也是从 Nextjs 文档中找到的。之前在 Boss 上看到有一些项目用 Vitest 测试，所以也使用它构建了一个测试环境。用 `src/test/` 文件夹来管理测试代码。主要的生成方式，是让 AI 来生成，人工复查。

此外，也用到了 Rest Client 插件，用来测试 API 端点。直接请求端点数据。

## 05 删除和搜索

逻辑方面就不多赘述，跟着鱼皮做的。值得一提的是用了改造的 session、用 TRPCError 改造了错误处理。

session 方面，是学习了[ Nextjs 的教程](https://nextjs.org/docs/app/building-your-application/authentication#session-management)，写在了 `src/server/utils/session.ts` 文件中。主要是加密、解密、session 的创建、更新、删除等函数，用到了 Nextjs 自带的 headers 设置，JWT，以及 coockies 等。

但由于这个得等到实际网站才能测试，有点难搞，在这阶段虽然已经做好了，但还没发测试。

也有一个迷思，究竟是用 session 结合 coockies 的方案，还是用 Authoritarian headers 更好？之后再说。

## 06 前端，注册和登录

鱼皮的前端直接用到了基于 React 的 Ani Design Pro，但我更喜欢 Shadcn/UI + TailwindCSS，所以得自己写（我勒个自己写）。还是多用 AI 生成，加自己审核和修改。

更快的方法是去 [21st.dev 网站的组件清单中找合适的](https://21st.dev/?tab=categories)，这是 Shadcn/UI 哲学的、组件库的组件库，可以通过命令直接下载组件到本地，支持 MCP。

它收集的[注册组件](https://21st.dev/s/registration-signup)和[登录组件](https://21st.dev/s/sign-in)都可以看看有没有喜欢的。

[Aceternity UI](https://ui.aceternity.com/)，更好看。

导入组件库式的 [Hero UI (Next UI)](https://www.heroui.com)，也有很多好看的内容。用到了 Toast 组件，也就是 antd 的 Message 组件。注意这个组件库的 Tailwindcss 4.x 版本是 beta 版本，需要按照 @beta 方式下载包。最后没有成功。还是换回了 Shadcn/UI 的 sooner，[Sonner 文档](https://sonner.emilkowal.ski/getting-started)。

axios 前后端联调，用 axios 代替 fetch。注意类型定义，try catch finanly。

[TankstackQuery](https://tanstack.com/query/latest/docs/framework/react/overview) : 原版 signUpForm.tsx TankstackQuery 版 signInForm.tsx。tankstack 定义好了主要的函数、方法、副作用。主要配置 QueryClientProvider，用 useQuery 和 useMutation。Devtools 可以方便调试，有一个按钮，可以看到 useQuery 和 useMutation 的状态、结果。又因为 tRPC 实际上基于 TanstackQuery，所以不用再次导入 QueryClientProvider，直接开始使用。



新学到的技巧：

- tailwindcss 的 group 分组：`group/btn:*` -> `group-hover/btn:*`

- Pick 方法从 react 类型提取特定类型：`{ currentTarget, clientX, clientY  }: Pick<React.MouseEvent<HTMLDivElement>'currentTarget' | 'clientX' | 'clientY'>`

- 忽略 eslint 文件：`export default testlint.config({ ignores: [".next","src/test/**/*"] })`

## 07 代理

正向代理：client --> proxy --> server1/server2/server3

反向代理：server --> proxy --> client

